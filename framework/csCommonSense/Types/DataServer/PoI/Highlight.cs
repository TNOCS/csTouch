using System.IO;
using System.Xml;
using Caliburn.Micro;
using csCommon.Types.DataServer.Interfaces;
using csCommon.Utils;
using csGeoLayers;
using csShared.Utils;
using DataServer;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Media;
using System.Xml.Linq;
using Jace;
using ProtoBuf;



namespace PoiServer.PoI
{
    using System.Windows.Media.Imaging;

    [ProtoContract, ProtoInclude(100, typeof(KeywordFilter))]
    [DebuggerDisplay("{Title}: Select {SelectionCriteria} of type {SelectionType} as {ValueType} and display it as {VisualType}.")]
    public class Highlight : PropertyChangedBase, IConvertibleXml
    {
        private readonly List<PoiProperty> criteria = new List<PoiProperty>();
        private string mathFormula;
        private object resultFormula;
         //private const int DefaultNumberOfLegendLevels = 5;
        private bool showInGui = true;
        //private int autoGeneratedLegendLevels;

        public PoIStyle Style { get; set; }

        private double thresHoldValue;

        [ProtoMember(1)]
        public double ThresHoldValue
        {
            get { return thresHoldValue; }
            set
            {
                thresHoldValue = value;
                NotifyOfPropertyChange(() => ThresHoldValue);
            }
        }

        private bool isEnabled;
        [ProtoMember(2)]
        public bool IsEnabled
        {
            get { return isEnabled; }
            set { isEnabled = value; NotifyOfPropertyChange(() => IsEnabled); }
        }

        private double minValue;
        [ProtoMember(3)]
        public double MinValue
        {
            get { return minValue; }
            set { minValue = value; NotifyOfPropertyChange(() => MinValue); }
        }

        private double maxValue;
        [ProtoMember(4)]
        public double MaxValue
        {
            get { return maxValue; }
            set { maxValue = value; NotifyOfPropertyChange(() => MaxValue); }
        }

        private Palette palette;
        [ProtoMember(5)]
        public Palette Palette
        {
            get { return palette; }
            set { palette = value; NotifyOfPropertyChange(() => Palette); }
        }

        [ProtoMember(6)]
        public int Priority { get; set; }

        private string title;

        /// <summary>
        /// Title is used for displaying it in the GUI
        /// </summary>
        [ProtoMember(7)]
        public string Title
        {
            get { return title; }
            set { title = value; NotifyOfPropertyChange(() => Title); }
        }

        /// <summary>
        /// When using the title as a label, make sure that it is a save name, i.e. not containing illegal characters.
        /// </summary>
        private string LabelTitle { get { return XmlConvert.EncodeName(title); }}

        public void UpdateTitle()
        {
            Title = string.Format("{0}->{1}{2}", PoiType, SelectionCriteria, HighlighterType == HighlighterTypes.FilterThreshold ? " filter" : string.Empty);
        }

        /// <summary>
        /// Indicates whether a highlighter uses multiple PoI properties instead of just one.
        /// </summary>
        public bool UsesMultipleCriteria
        {
            get { return usesMultipleCriteria; }
            private set {
                if (usesMultipleCriteria == value) return;
                usesMultipleCriteria = value; 
                NotifyOfPropertyChange(() => UsesMultipleCriteria);
            }
        }

        /// <summary>
        /// In MCA mode, i.e. the formula is in the form of w1*a+w2*b+w3*c..., where w_i=[0..1]
        /// </summary>
        public bool InMcaMode
        {
            get { return inMcaMode; }
            set
            {
                if (inMcaMode == value) return;
                inMcaMode = value;
                if (!inMcaMode) 
                {
                    foreach (var c in criteria) c.Weight = 0;
                }
                UpdateMathFormula();
                NotifyOfPropertyChange(() => InMcaMode);
            }
        }

        private SelectionTypes selectionType;

        /// <summary>
        /// Select the attribute type
        /// </summary>
        [ProtoMember(8)]
        public SelectionTypes SelectionType
        {
            get { return selectionType; }
            set
            {
                if (selectionType == value) return;
                selectionType = value;
                NotifyOfPropertyChange(() => SelectionType);
            }
        }

        private string selectionCriteria;

        /// <summary>
        /// What is the attribute's value
        /// </summary>
        [ProtoMember(9)]
        public string SelectionCriteria
        {
            get { return selectionCriteria; }
            set
            {
                if (selectionCriteria == value) return;
                selectionCriteria = value;
                NotifyOfPropertyChange(() => SelectionCriteria);
            }
        }

        /// <summary>
        /// What type of value are we dealing with
        /// </summary>
        [ProtoMember(10)]
        public ValueTypes ValueType { get; set; }

        private string category = DefaultCategory;

        [ProtoMember(11)]
        public string Category
        {
            get { return category; }
            set { category = value; NotifyOfPropertyChange(() => Category); }
        }

        private ThresholdTypes thresholdType;

        /// <summary>
        /// What type of threshold are we dealing with
        /// </summary>
        [ProtoMember(12)]
        public ThresholdTypes ThresholdType
        {
            get { return thresholdType; }
            set { thresholdType = value; NotifyOfPropertyChange(() => ThresholdType); }
        }

        private VisualTypes visualType;

        /// <summary>
        /// How do you wish to display the result
        /// </summary>
        [ProtoMember(13)]
        public VisualTypes VisualType
        {
            get { return visualType; }
            set { visualType = value; NotifyOfPropertyChange(() => VisualType); }
        }


        private string stringValue;

        public string StringValue
        {
            get { return stringValue; }
            set { stringValue = value; NotifyOfPropertyChange(()=>StringValue); }
        }
        
        private HighlighterTypes highlighterType;

        /// <summary>
        /// Defines the kind of highlighter or filter.
        /// </summary>
        [ProtoMember(14)]
        public HighlighterTypes HighlighterType
        {
            get { return highlighterType; }
            set
            {
                if (highlighterType == value) return;
                highlighterType = value;
                NotifyOfPropertyChange(() => HighlighterType);
            }
        }

        private bool isActive;
        /// <summary>
        /// When true, the filter should be applied immediately
        /// </summary>
        [ProtoMember(15)]
        public bool IsActive {
            get { return isActive; }
            set
            {
                if (isActive != value)
                {
                    isActive = value;
                    NotifyOfPropertyChange(()=>IsActive);
                }
            }
        }

        /// <summary>
        /// When true, the Min Max should be re-evaluated on add/remove
        /// </summary>
        [ProtoMember(20)]
        public bool IsDynamic { get; set; }

        ///// <summary>
        ///// When true, the filter should generate a legend automatically (only for numbers and percentages)
        ///// </summary>
        //public bool AutoGenerateLegend { get; set; }

        ///// <summary>
        ///// When AutoGenerateLegend is true, 
        ///// </summary>
        //public int AutoGeneratedLegendLevels
        //{
        //    get { return autoGeneratedLegendLevels > 0 ? autoGeneratedLegendLevels : DefaultNumberOfLegendLevels; }
        //    set { autoGeneratedLegendLevels = value; }
        //}

        //public LegendPalette AutoGeneratedlegendPalette { get; set; }
       
        private string poiType;
        private bool usesMultipleCriteria;
        private bool inMcaMode;

        [ProtoMember(17)]
        public string PoiType
        {
            get { return poiType; }
            set { poiType = value; NotifyOfPropertyChange(() => PoiType); }
        }

        public string MathFormula
        {
            get { return mathFormula; }
            set
            {
                if (string.Equals(mathFormula, value)) return;
                mathFormula = value;
                CreateResultFormula(mathFormula);
                NotifyOfPropertyChange(() => MathFormula);
            }
        }

        public List<PoiProperty> Criteria { get { return criteria; } }

        /// <summary>
        /// When true, display in the GUI.
        /// </summary>
        [ProtoMember(18)]
        public bool ShowInGui
        {
            get { return showInGui; }
            set { showInGui = value; }
        }

        public virtual void CalculateMin(PoiService service)
        {
            if (UsesMultipleCriteria)
            {
                minValue = service.PoIs.Where(p => p.PoiTypeId == PoiType).Min(p => CalculateResultUsingMultipleCriteria(p));
                //minValue = double.MaxValue;
                //foreach (var result in service.PoIs.Where(p => p.PoiTypeId == PoiType).Select(CalculateResultUsingMultipleCriteria).Where(result => result < curMin))
                //    curMin = result;
                //minValue = curMin;
            }
            else
            {
                switch (SelectionType)
                {
                    case SelectionTypes.Selected:
                        minValue = 0;
                        break;
                    case SelectionTypes.Label:
                        minValue = CalculateMinLabelValue(service);
                        break;
                    case SelectionTypes.Sensor:
                        //minValue = service.PoIs.Where(p => p.Sensors.ContainsKey(SelectionCriteria)).Min(p => p.Sensors[SelectionCriteria].Data.Min(k => k.Value));
                        minValue = CalculateMinSensorValue(service);
                        break;
                }
                if (minValue < 0.000001 && minValue > 0) minValue = 0.0;
            }
            if (!string.IsNullOrEmpty(StringFormat))
            {
                double result;
                if (double.TryParse(string.Format(CultureInfo.InvariantCulture, StringFormat, minValue),
                    NumberStyles.Number, CultureInfo.InvariantCulture, out result)) minValue = result;
            }
            NotifyOfPropertyChange(() => MinValue);
        }

        private double CalculateMinSensorValue(PoiService service)
        {
            var min = double.MaxValue;
            foreach (var v in service.PoIs.Where(p => p.PoiTypeId == PoiType && p.Sensors.ContainsKey(SelectionCriteria) && p.Sensors[SelectionCriteria].Data.Count > 0).Select(p => p.Sensors[SelectionCriteria].Data.Min(k => k.Value)))
            {
                //foreach (var p in service.PoIs.Where(p => p.Sensors.ContainsKey(SelectionCriteria))) {
                //var v = p.Sensors[SelectionCriteria].Data.Min(k => k.Value);
                if (v < min && v != -99999997) min = v;
            }
            return min;
        }

        private double CalculateMinLabelValue(PoiService service)
        {
            var min = double.MaxValue;
            foreach (var p in service.PoIs.Where(p => p.PoiTypeId == PoiType && p.Labels.ContainsKey(SelectionCriteria)))
            {
                double v;
                if (!double.TryParse(p.Labels[SelectionCriteria], NumberStyles.Any, CultureInfo.InvariantCulture, out v))
                    continue;
                if (v < min && v != -99999997) min = v;
            }
            return min >= double.MaxValue ? 0 : min;
        }

        public virtual void CalculateMax(PoiService service)
        {
            if (UsesMultipleCriteria)
            {
                maxValue = service.PoIs.Where(p => p.PoiTypeId == PoiType).Max(p => CalculateResultUsingMultipleCriteria(p));
                //maxValue = double.MinValue;
                //foreach (var result in service.PoIs.Where(p => p.PoiTypeId == PoiType).Select(CalculateResultUsingMultipleCriteria).Where(result => result > curMax))
                //    curMax = result;
                //maxValue = curMax;
            }
            else
            {
                switch (SelectionType)
                {
                    case SelectionTypes.Selected:
                        maxValue = 1;
                        break;
                    case SelectionTypes.Label:
                        maxValue = double.MinValue;
                        foreach (
                            var p in
                                service.PoIs.Where(
                                    p => p.PoiTypeId == PoiType && p.Labels.ContainsKey(SelectionCriteria)))
                        {
                            double v;
                            if (
                                !double.TryParse(p.Labels[SelectionCriteria], NumberStyles.Any,
                                    CultureInfo.InvariantCulture, out v)) continue;
                            if (v > maxValue && v != -99999997) maxValue = v;
                        }
                        if (maxValue <= double.MinValue) maxValue = 1; // No element found
                        break;
                    case SelectionTypes.Sensor:
                        //maxValue = service.PoIs.Where(p => p.Sensors.ContainsKey(SelectionCriteria)).Max(p => p.Sensors[SelectionCriteria].Data.Max(k => k.Value));
                        maxValue = double.MinValue;
                        foreach (
                            var v in
                                service.PoIs.Where(
                                    p =>
                                        p.Sensors.ContainsKey(SelectionCriteria) &&
                                        p.Sensors[SelectionCriteria].Data.Count > 0)
                                    .Select(p => p.Sensors[SelectionCriteria].Data.Max(k => k.Value)))
                        {
                            maxValue = v;
                        }
                        break;
                }
            }
            if (!string.IsNullOrEmpty(StringFormat))
            {
                double result;
                if (double.TryParse(string.Format(CultureInfo.InvariantCulture, StringFormat, maxValue),
                    NumberStyles.Number, CultureInfo.InvariantCulture, out result)) maxValue = result;
            }
            NotifyOfPropertyChange(() => MaxValue);
        }

        ///// <summary>
        ///// Optional element detailing the legend.
        ///// </summary>
        //public List<LegendItem> Legend { get; set; }

        ///// <summary>
        ///// Optional element specifying the criteria for multi criteria analysis.
        ///// </summary>
        //public List<Criterion> Criteria { get; set; }

        public string XmlNodeId
        {
            get { return "Highlight"; }
        }

        public virtual void FromXml(XElement hx)
        {
            try
            {
                // TODO Should we set the property or the backing field?
                Title = hx.GetString("Title");
                UsesMultipleCriteria = hx.GetBool("usesMultipleCriteria");
                ShowInGui = hx.GetBool("ShowInGui", true);
                IsActive = hx.GetBool("IsActive");
                IsDynamic = hx.GetBool("IsDynamic");
                HighlighterType = (HighlighterTypes)Enum.Parse(typeof(HighlighterTypes), hx.GetString("HighlighterType", "Highlight"));
                VisualType = (VisualTypes)Enum.Parse(typeof(VisualTypes), hx.GetString("VisualType", "StrokeColor"));
                ValueType = (ValueTypes)Enum.Parse(typeof(ValueTypes), hx.GetString("ValueType", "String"));
                MinValue = hx.GetDouble("MinValue");
                MaxValue = hx.GetDouble("MaxValue");
                ThresholdType = (ThresholdTypes)Enum.Parse(typeof(ThresholdTypes), hx.GetString("ThresholdType", "Equal"));
                SelectionCriteria = hx.GetString("SelectionCriteria", string.Empty);
                SelectionType = (SelectionTypes)Enum.Parse(typeof(SelectionTypes), hx.GetString("SelectionType", "Label"));
                ThresHoldValue = hx.GetDouble("ThresHoldValue", 0.0);
                StringValue = hx.GetString("StringValue", string.Empty);
                StringFormat = hx.GetString("StringFormat", string.Empty);
                PoiType = hx.GetString("PoiType", string.Empty);
                var px = hx.Element("Palette");
                Category = hx.GetString("Category", DefaultCategory);
                if (px == null) return;
                Palette = new Palette();
                Palette.FromXml(px);

                if (!usesMultipleCriteria) return;
                var crit = hx.GetString("criteria").Split(new[] { '|' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var c in crit)
                {
                    var criterion = c.Split(new[] { ':' }, StringSplitOptions.RemoveEmptyEntries);
                    if (criterion.Length < 3) continue;
                    var st = (SelectionTypes)Enum.Parse(typeof(SelectionTypes), criterion[0], true);
                    double result;
                    if (double.TryParse(criterion[2], NumberStyles.Number, CultureInfo.CurrentCulture, out result))
                        criteria.Add(new PoiProperty { Name = criterion[1], Type = st, Weight = result });
                }
                inMcaMode = hx.GetBool("inMcaMode");
                CreateResultFormula(hx.GetString("mathFormula"));
            }
            catch (Exception e)
            {
                Logger.Log("AnalysisMetaInfo", "Error parsing xml", e.Message, Logger.Level.Error);
            }
        }

        public virtual XElement ToXml()
        {
            var x = new XElement("Highlight");
            x.SetAttributeValue("Title", Title);
            if (usesMultipleCriteria)
            {
                x.SetAttributeValue("mathFormula", mathFormula);
                x.SetAttributeValue("usesMultipleCriteria", usesMultipleCriteria);
                x.SetAttributeValue("inMcaMode", inMcaMode);
                x.SetAttributeValue("criteria", string.Join("|", criteria.Select(c => string.Format("{0}:{1}:{2:0.######}", c.Type, c.Name, c.Weight))));
            }
            x.SetAttributeValue("ShowInGui", ShowInGui);
            x.SetAttributeValue("IsActive", IsActive);
            x.SetAttributeValue("IsDynamic", IsDynamic);
            x.SetAttributeValue("HighlighterType", HighlighterType);
            x.SetAttributeValue("VisualType", VisualType);
            x.SetAttributeValue("MinValue", MinValue);
            x.SetAttributeValue("MaxValue", MaxValue);
            x.SetAttributeValue("ThresholdType", ThresholdType);
            x.SetAttributeValue("SelectionCriteria", SelectionCriteria);
            if (SelectionType != SelectionTypes.Label) x.SetAttributeValue("SelectionType", SelectionType);
            x.SetAttributeValue("ThresHoldValue", ThresHoldValue);
            x.SetAttributeValue("StringValue", StringValue);
            x.SetAttributeValue("StringFormat", StringFormat);
            x.SetAttributeValue("ValueType", ValueType);
            x.SetAttributeValue("PoiType", PoiType);
            if (Category != DefaultCategory) x.SetAttributeValue("Category", Category);
            if (Palette != null) x.Add(Palette.ToXml());

            return x;
        }

        protected static string DefaultCategory
        {
            get { return "other"; }
        }

        [ProtoMember(19)]
        public string StringFormat { get; set; }


        //Todo: Add function to partition string into categories
        public virtual void CalculateCategories(PoiService service)
        {
            var res = new Dictionary<object, int>();
            foreach (var p in service.PoIs)
            {
                if (p.Labels.ContainsKey(selectionCriteria))
                {
                    if (res.ContainsKey(p.Labels[selectionCriteria]))
                    {
                        res[p.Labels[selectionCriteria]]++;
                    }
                    else
                    {
                        res[p.Labels[selectionCriteria]] = 0;
                    }
                }
            }
            Histogram = res;
            if (Histogram.Count < 9)
                CreatePallette(Histogram.Count, "Diverging", "BrBG", false);
        }


        public static Dictionary<object,int> Histogram = new Dictionary<object, int>();
 
        public virtual void CreatePallette(int categories, string type, string name, bool gradient)
        {
            var colorlist = ColorBrewer.ColorTemplates.FirstOrDefault(k => k.Type == type && k.NumberOfColors == categories && k.Name == name);
            if (colorlist != null)
            {
                if (gradient)
                {
                    Palette.Stops.Clear();
                    for (int i = 0; i < colorlist.Colors.Count; i++)
                    {
                        Palette.Stops.Add(new PaletteStop() { Color = colorlist.Colors[i], StopValue = i });
                    }
                }
                else
                {
                    Palette.Stops.Clear();
                    var increment = 1.0 / colorlist.Colors.Count;
                    for (int i = 1; i <= colorlist.Colors.Count; i++)
                    {
                        Palette.Stops.Add(new PaletteStop() { Color = colorlist.Colors[i], StopValue = (i - 1) * increment });
                        Palette.Stops.Add(new PaletteStop() { Color = colorlist.Colors[i], StopValue = ((i) * increment) });
                    }
                }
            }
        }

        private static Color GetStringHighlightColor(Highlight hl, string value)
        {
            if (hl.Palette == null) return Colors.Black;
            var linbrush = hl.Palette.GetBrush();
            
            var hist = Histogram.IndexOf(k => k.Key.ToString() == value);
            var count = linbrush.GradientStops.Count > 9 ? linbrush.GradientStops.Count/2 : linbrush.GradientStops.Count;
            var p = (double) (hist)/count + .1/count;
            var c = ColorHelper.GetColorAtPoint(linbrush, new Point(p, 0.0));
            return c;
        }



        public virtual void CalculateResult(BaseContent bc)
        {
            switch (HighlighterType)
            {
                case HighlighterTypes.Direct:
                    break;
                case HighlighterTypes.FilterThreshold:
                    double fvalue = 0;
                    var svalue = string.Empty;
                    if (UsesMultipleCriteria) {
                        fvalue = CalculateResultUsingMultipleCriteria(bc);
                    }
                    else {
                        switch (SelectionType)
                        {
                            case SelectionTypes.Label:
                                try
                                {
                                    switch (ValueType)
                                    {
                                        case ValueTypes.Number:
                                            fvalue = ParseLabelToDouble(bc, SelectionCriteria);
                                            break;
                                        case ValueTypes.String:
                                            if (!bc.Labels.ContainsKey(SelectionCriteria)) break;
                                            if (ValueType == ValueTypes.String) svalue = bc.Labels[SelectionCriteria];
                                            break;
                                    }                                    
                                }
                                catch (SystemException e)
                                {
                                    Console.WriteLine(e.Message);
                                }
                                break;
                            case SelectionTypes.Sensor:
                                fvalue = GetSensorValue(bc, SelectionCriteria);
                                break;
                        }
                    }

                    switch (ValueType)
                    {
                        case ValueTypes.Number:
                            switch (ThresholdType)
                            {
                                case ThresholdTypes.LessOrEqual:
                                    bc.NAnalysisStyle.Visible = fvalue <= ThresHoldValue;
                                    break;
                                case ThresholdTypes.GreaterOrEqual:
                                    bc.NAnalysisStyle.Visible = fvalue > ThresHoldValue;
                                    break;
                                case ThresholdTypes.NotEqual:
                                    bc.NAnalysisStyle.Visible = Math.Abs(fvalue - ThresHoldValue) > 0.000001;
                                    break;
                                case ThresholdTypes.Equal:
                                    bc.NAnalysisStyle.Visible = Math.Abs(fvalue - ThresHoldValue) < 0.000001;
                                    break;
                                case ThresholdTypes.Greater:
                                    bc.NAnalysisStyle.Visible = fvalue > ThresHoldValue;
                                    break;
                                case ThresholdTypes.Less:
                                    bc.NAnalysisStyle.Visible = fvalue < ThresHoldValue;
                                    break;
                            }
                            break;
                        case ValueTypes.String:
                            switch (ThresholdType)
                            {
                                case ThresholdTypes.Equal:
                                    bc.NAnalysisStyle.Visible = string.Equals(svalue, StringValue, StringComparison.InvariantCultureIgnoreCase);
                                    break;
                                case ThresholdTypes.NotEqual:
                                    bc.NAnalysisStyle.Visible = !string.Equals(svalue, StringValue, StringComparison.InvariantCultureIgnoreCase);
                                    break;
                                case ThresholdTypes.Greater:
                                    bc.NAnalysisStyle.Visible = String.CompareOrdinal(svalue, StringValue) > 0;
                                    break;
                                case ThresholdTypes.GreaterOrEqual:
                                    bc.NAnalysisStyle.Visible = String.CompareOrdinal(svalue, StringValue) >= 0;
                                    break;
                                case ThresholdTypes.Less:
                                    bc.NAnalysisStyle.Visible = String.CompareOrdinal(svalue, StringValue) < 0;
                                    break;
                                case ThresholdTypes.LessOrEqual:
                                    bc.NAnalysisStyle.Visible = String.CompareOrdinal(svalue, StringValue) <= 0;
                                    break;
                                case ThresholdTypes.Contains:
                                    bc.NAnalysisStyle.Visible = svalue.Contains(StringValue);
                                    break;
                                case ThresholdTypes.DoesNotContain:
                                    bc.NAnalysisStyle.Visible = !svalue.Contains(StringValue);
                                    break;
                            }
                            break;
                    }
                    break;
                case HighlighterTypes.Highlight:
                    double value = 0;
                    if (UsesMultipleCriteria)
                        value = CalculateResultUsingMultipleCriteria(bc);
                    else {
                        if (SelectionCriteria != null)
                        {
                            switch (SelectionType)
                            {
                                case SelectionTypes.Label:
                                    value = ParseLabelToDouble(bc, SelectionCriteria);
                                    break;
                                case SelectionTypes.Selected:
                                    var poi = bc as DataServer.PoI;
                                    if (poi == null) break;
                                    value = poi.IsSelected ? MaxValue : MinValue;
                                    if (VisualType == VisualTypes.StrokeWidth)
                                        value = (value / 10 - 0.1) * MaxValue;
                                    // Compensate for weird GetStrokeWidth function 
                                    break;
                                case SelectionTypes.Sensor:
                                    value = GetSensorValue(bc, SelectionCriteria);
                                    break;
                            }
                        }
                    }

                    switch (VisualType)
                    {
                        case VisualTypes.FillColor:
                            if (ValueType == ValueTypes.String && SelectionCriteria != null  && bc.Labels.ContainsKey(SelectionCriteria))
                                bc.NAnalysisStyle.FillColor = GetStringHighlightColor(this, bc.Labels[SelectionCriteria]);
                            else
                                bc.NAnalysisStyle.FillColor = GetHighlightColor(this, value);
                            break;
                        case VisualTypes.Opacity:
                            bc.NAnalysisStyle.StrokeOpacity = bc.NAnalysisStyle.FillOpacity = GetOpacity(this, value);
                            break;
                        case VisualTypes.Icon:
                            if (SelectionCriteria != null && bc.Labels.ContainsKey(SelectionCriteria))
                            {
                                var newIcon = GetIcon(this, bc.Labels[SelectionCriteria]);
                                if (File.Exists(Path.Combine(bc.Service.MediaFolder, newIcon))) bc.NAnalysisStyle.Icon = newIcon;
                                else 
                                {
                                    // Icon (newIcon) not found in media directory, create default error icon (to show on the map)
                                    try
                                    {
                                        var icon_not_found = "icon_not_found_" + newIcon;
                                        if (!File.Exists(Path.Combine(bc.Service.MediaFolder, icon_not_found)))
                                        {
                                            
                                            var errorIcon =
                                                new BitmapImage(
                                                    new Uri(
                                                        "pack://application:,,,/csCommon;component/Resources/Icons/IconNotFound.png"));

                                            var encoder = new PngBitmapEncoder();
                                            encoder.Frames.Add(BitmapFrame.Create((BitmapImage)errorIcon));
                                            using (
                                                var filestream =
                                                    new FileStream(
                                                        Path.Combine(bc.Service.MediaFolder, icon_not_found),
                                                        FileMode.Create)) encoder.Save(filestream);
                                        }
                                        bc.NAnalysisStyle.Icon = icon_not_found;
                                    }
                                    catch (Exception)
                                    {
                                        // Dont care
                                    }

                                    
                                }
                            }
                            break;
                        case VisualTypes.StrokeWidth:
                            bc.NAnalysisStyle.StrokeWidth = GetStrokeWidth(this, value);
                            break;
                        case VisualTypes.StrokeColor:
                            bc.NAnalysisStyle.StrokeColor = GetHighlightColor(this, value);
                            break;
                        case VisualTypes.SymbolSize:
                            bc.NAnalysisStyle.IconHeight = bc.NAnalysisStyle.IconWidth = GetSymbolSize(this, value);
                            break;
                    }
                    break;
            }
        }

        private static double GetSensorValue(BaseContent bc, string key)
        {
            var fvalue = 0d;
            if (bc.Sensors.Count > 0 && bc.Sensors.ContainsKey(key))
                fvalue = bc.Sensors[key].FocusValue;
            return fvalue;
        }

        /// <summary>
        /// Try to parse the label to a double using either the invariant or the Dutch culture.
        /// </summary>
        /// <param name="bc"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        private static double ParseLabelToDouble(BaseContent bc, string key)
        {
            if (!bc.Labels.ContainsKey(key)) return 0;
            double fvalue;
            if (double.TryParse(bc.Labels[key], NumberStyles.Any, CultureInfo.InvariantCulture, out fvalue)) return fvalue;
            double.TryParse(bc.Labels[key], NumberStyles.Any, new CultureInfo("NL-nl"), out fvalue);
            return fvalue;
        }

        private static double GetStrokeWidth(Highlight hl, double value)
        {
            try
            {
                var p = Math.Max(0.1, 0.1 + Math.Min(1.0, (value - hl.MinValue) / (hl.MaxValue - hl.MinValue)));
                var r = Math.Max(1.0, p * 10.0);
                return r;
            }
            catch (Exception)
            {
                return 0.0;
            }
        }

        private static double GetOpacity(Highlight hl, double value)
        {
            try
            {
                var p = Math.Max(0, Math.Min(0.9, (value - hl.MinValue) / (hl.MaxValue - hl.MinValue)));
                return p;
            }
            catch (Exception)
            {
                return 0.0;
            }
        }

        private static double GetSymbolSize(Highlight hl, double value)
        {
            try
            {
                var p = Math.Max(0.4, 0.4 + Math.Min(1.0, (value - hl.MinValue) / (hl.MaxValue - hl.MinValue)));
                var r = Math.Sqrt(Math.Max(1.0, p * 1000.0));
                return r;
            }
            catch (Exception)
            {
                return 0.0;
            }
        }

        private static string GetIcon(Highlight hl, string value)
        {
            return string.Format("{0}_{1}.png", hl.SelectionCriteria, value);
        }

        private static Color GetHighlightColor(Highlight hl, double value)
        {
            
            if (hl.Palette == null) return Colors.Black;
            //if (hl.TempBrush == null) hl.TempBrush = hl.Palette.GetBrush(); 
            var linbrush = hl.Palette.GetBrush();
            var p = (value - hl.MinValue) / (hl.MaxValue - hl.MinValue);
            var c = ColorHelper.GetColorAtPoint(linbrush, new Point(p, 0.0));
            return c;
        }

        #region Multiple criteria 

        /// <summary>
        /// Initializes the multiple criteria and creates an initial MCA function (weigthed values) 
        /// for the evaluation.
        /// </summary>
        /// <param name="p"></param>
        public void UpdateMultipleCriteria(BaseContent p) {
            criteria.Clear();
            mathFormula = string.Empty;
            RemoveMetaInfo(p);
            if (CreateCriteria(p)) return;
            UsesMultipleCriteria = criteria.Count > 0;
            if (!usesMultipleCriteria) return;
            // For example: 0.333*a+0.333*b+0.333*c
            UpdateMathFormula();
            InMcaMode = true;
            CreateMetaInfo(p);
        }

        public void UpdateMathFormula()
        {
            var variable = 'a';
            var totalWeight = criteria.Sum(c => c.Weight);
            if (Math.Abs(totalWeight) < 0.01) totalWeight = 1;
            var formula = string.Join("+", criteria.Select(x => string.Format(CultureInfo.InvariantCulture, "{0:0.####}*{1}", x.Weight/totalWeight, variable++)));
            CreateResultFormula(formula);
        }

        /// <summary>
        /// Create the multiple criteria based on the SelectionCriteria.
        /// </summary>
        /// <param name="p"></param>
        /// <returns>True if there is only a single criterion.</returns>
        private bool CreateCriteria(BaseContent p)
        {
            var crit = SelectionCriteria.Split(new[] {' ', '\r', '\n'}, StringSplitOptions.RemoveEmptyEntries).ToList();
            var usesMultiple = crit.Count > 1;
            if (!usesMultiple) return true;
            var w = 1d/crit.Count;
            foreach (var criterion in crit)
            {
                var mi = p.MetaInfo.FirstOrDefault(i => string.Equals(i.Label, criterion, StringComparison.InvariantCultureIgnoreCase));
                if (mi == null) continue;
                criteria.Add(new PoiProperty
                {
                    Name = criterion,
                    Weight = w,
                    Type = mi.Type == MetaTypes.sensor ? SelectionTypes.Sensor : SelectionTypes.Label
                });
            }
            return false;
        }

        private void RemoveMetaInfo(BaseContent bc) {
            var mi = bc.MetaInfo.FirstOrDefault(m => string.Equals(m.Label, LabelTitle, StringComparison.InvariantCultureIgnoreCase));
            if (mi != null) bc.MetaInfo.Remove(mi);
        }

        private void CreateMetaInfo(BaseContent bc) {
            bc.MetaInfo.Add(new MetaInfo { Label = LabelTitle, Title = Title, IsEditable = false, Section = "Results", Type = MetaTypes.number, StringFormat = "{0:0.00}", VisibleInCallOut = true });
        }

        private void CreateResultFormula(string formula)
        {
            if (string.IsNullOrEmpty(formula)) return;
            MathFormula = formula;
            var engine = new CalculationEngine(CultureInfo.InvariantCulture);
            var formulaBuilder = engine.Formula(mathFormula).Result(Jace.DataType.FloatingPoint);
            var variable = 'a';
            for (var i = 0; i < criteria.Count; i++)
                formulaBuilder.Parameter("" + variable++, Jace.DataType.FloatingPoint);
            resultFormula = formulaBuilder.Build();
        }

        /// <summary>
        /// Calculate the results using the created formula.
        /// Note that you can have up to 8 parameters.
        /// </summary>
        /// <param name="bc"></param>
        /// <returns>The computed result.</returns>
        private double CalculateResultUsingMultipleCriteria(BaseContent bc) {
            var parameters = new double[criteria.Count];
            for (var i = 0; i < criteria.Count; i++) {
                var criterion = criteria[i];
                parameters[i] = criterion.Type == SelectionTypes.Label
                    ? ParseLabelToDouble(bc, criterion.Name)
                    : GetSensorValue(bc, criterion.Name);
            }
            var result = 0d;
            switch (parameters.Length) {
                case 2: {
                    var formula = resultFormula as Func<double, double, double>;
                    result = formula == null ? 0 : formula(parameters[0], parameters[1]);
                    break;
                }
                case 3: {
                    var formula = resultFormula as Func<double, double, double, double>;
                    result = formula == null ? 0 : formula(parameters[0], parameters[1], parameters[2]);
                    break;
                }
                case 4: {
                    var formula = resultFormula as Func<double, double, double, double, double>;
                    result = formula == null ? 0 : formula(parameters[0], parameters[1], parameters[2], parameters[3]);
                    break;
                }
                case 5: {
                    var formula = resultFormula as Func<double, double, double, double, double, double>;
                    result = formula == null ? 0 : formula(parameters[0], parameters[1], parameters[2], parameters[3], parameters[4]);
                    break;
                }
                case 6: {
                    var formula = resultFormula as Func<double, double, double, double, double, double, double>;
                    result = formula == null ? 0 : formula(parameters[0], parameters[1], parameters[2], parameters[3], parameters[4], parameters[5]);
                    break;
                }
                case 7: {
                    var formula = resultFormula as Func<double, double, double, double, double, double, double, double>;
                    result = formula == null ? 0 : formula(parameters[0], parameters[1], parameters[2], parameters[3], parameters[4], parameters[5], parameters[6]);
                    break;
                }
                case 8: {
                    var formula = resultFormula as Func<double, double, double, double, double, double, double, double, double>;
                    result = formula == null ? 0 : formula(parameters[0], parameters[1], parameters[2], parameters[3], parameters[4], parameters[5], parameters[6], parameters[7]);
                    break;
                }
            }
            bc.Labels[LabelTitle] = result.ToString(CultureInfo.InvariantCulture);
            //bc.TriggerLabelChanged("Results are updated", string.Empty, string.Empty);
            return result;
        }

        #endregion Multiple criteria

        public void CleanUp(PoiService service)
        {
            // Remove the metainfo in the popup
            var pt = service.PoITypes.FirstOrDefault(p => string.Equals(p.ContentId, PoiType));
            if (pt == null) return;
            RemoveMetaInfo(pt);
            // Remove the labels that were added
            var key = LabelTitle;
            foreach (var p in service.PoIs.Where(p => string.Equals(p.PoiTypeId, PoiType)))
                p.Labels.Remove(key);
        }

    }

    /// <summary>
    /// Simple internal class for managing the properties when using multiple criteria.
    /// </summary>
    [DebuggerDisplay("{Name}, {Type}, {Weight}")]
    public class PoiProperty : PropertyChangedBase
    {
        private double weight;
        private string name;

        public string Name
        {
            get { return name; }
            set
            {
                if (string.Equals(name, value)) return;
                name = value;
                NotifyOfPropertyChange(() => Name);
            }
        }

        public SelectionTypes Type { get; set; }

        public double Weight
        {
            get { return weight; }
            set
            {
                if (Math.Abs(weight - value) < 0.000001) return;
                weight = value;
                NotifyOfPropertyChange(() => Weight);
            }
        }
    }

    /// <summary>
    /// Specific keyword filter that allows you to turn on/off a PoIs visibility based on the existance of a keyword in the label. 
    /// </summary>
    [ProtoContract]
    [DebuggerDisplay("{Title}: Select {SelectionCriteria} of type {SelectionType} as {ValueType} and display it as {VisualType}.")]
    public class KeywordFilter : Highlight
    {
         // IMB needs empty constructor (protobuf)
        public KeywordFilter() { }

        public KeywordFilter(BaseContent bc, string label, string keyword, string title = "Keyword filter")
        {
            StringValue = keyword.ToLower();
            SelectionCriteria = label;

            Title = title;
            HighlighterType = HighlighterTypes.FilterThreshold;
            PoiType = bc.ContentId;
            SelectionType = SelectionTypes.Label;
            ValueType = ValueTypes.String;
            VisualType = VisualTypes.Icon;
            ThresholdType = ThresholdTypes.DoesNotContain;
            MaxValue = double.MaxValue; // Set to prevent the filter from calculating the min and max.
        }

        public override void CalculateResult(BaseContent bc)
        {
            string userIdentity;
            if (!bc.Labels.TryGetValue(SelectionCriteria, out userIdentity)) return;
            if (userIdentity.ToLower().Contains(StringValue))
                bc.NAnalysisStyle.Visible = false;
        }
    }

}